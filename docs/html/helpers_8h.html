<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<LINK href="doxygen.css" rel="stylesheet" type="text/css">
<title>MazBotV4 Helpers API</title>
</head>
<body>
<h1>MazBotV4 Helpers API</h1>
<b>
<ul>
<li>Cexplode</li>
<li>Atomic oerations</li>
<li>Linked list</li>
</ul>
</b>
<p>
<b>Copyright</b><br>
<pre>
/* **********************************************************************/
/*                                                                      *
 *      Implementation of php's explode written in C                    *
 *      Written by  Maz (2008)                                          *
 *      Added Atomic operations for x86 architecture and                *
 *      Linked list implementation.                                     *
 *      Written by  Maz (2009-2010)                                     *
 *      http://maz-programmersdiary.blogspot.com/                       *
 *                                                                      *
 *      You're free to use this piece of code.                          *
 *      You can also modify it freely, but if you                       *
 *      improve this, you must write the improved code                  *
 *      in comments at:                                                 *
 *      http://maz-programmersdiary.blogspot.com/                       *
 *      or at:                                                          *
 *      http://c-ohjelmoijanajatuksia.blogspot.com/                     *
 *      or mail the corrected version to me at                          *
 *      Mazziesaccount@gmail.com                                        *
 *                                                                      *
 *      Revision History:                                               *
 *                                                                      *
 *      - 0.0.6 15.08.2009/Maz  Fixed atomic CAS                        *
 *      - 0.0.5 11.08.2009/Maz  Added Cexplode_free_allButPieces        *
 *      - 0.0.4 11.08.2009/Maz  Added atomic ops and                    *
 *                              mbot_ll                                 *
 *      -v0.0.3 31.07.2009/Maz  Added Cexplode_concat                   *
 *                              (untested)                              *
 *      -v0.0.2 21.07.2009/Maz  Some additions for better               *
 *                              usability in MazBotV4                   *
 *      -v0.0.1 16.09.2008/Maz                                          *
 *                                                                      */
/* ******************************************************************** */
</pre>
<p>

<!-- Generated by Doxygen 1.6.1 -->
<div class="contents">
<h1>helpers.h File Reference</h1><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;semaphore.h&gt;</code><br/>

<p><a href="helpers_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct for 32bit wide integer type used in atomic operations.  <a href="structMbotAtomic32.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct for Cexplode object.  <a href="structCexplodeStrings.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#abfdc88c318ac17df371af7b475163783">CEXPLODE_LAST_ITEM</a>&nbsp;&nbsp;&nbsp;0xFFFFFFFF</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a56c8f0f14ff2d468fabe0d3f568181df">ECexplodeRet</a> { <a class="el" href="helpers_8h.html#a56c8f0f14ff2d468fabe0d3f568181dfaaa011f9fda77271b2b6da4802a542aab">ECexplodeRet_InternalFailure</a> =  -666, 
<a class="el" href="helpers_8h.html#a56c8f0f14ff2d468fabe0d3f568181dfaa2ae017306e779c0558ea650bbc9fc78">ECexplodeRet_InvalidParams</a> =  -667
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>enumeration for Cexplodei's error return values </p>
 <a href="helpers_8h.html#a56c8f0f14ff2d468fabe0d3f568181df">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a64d6e9e5a93f8eab6d85501b9b50f5b4">Cexplode_removeCurrent</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the previously returned piece.  <a href="#a64d6e9e5a93f8eab6d85501b9b50f5b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a0c82e1b2630b7538bc756ffc7eaaeb9e">Cexplode_removeNth</a> (int nro, <a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes Nth piece from cexplode Must not be called before calling Cexplode If removed item is last piece, the "sepwasatend" flag will be set true! Note, you can use special CEXPLODE_LAST_ITEM define to remove the last item.  <a href="#a0c82e1b2630b7538bc756ffc7eaaeb9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a87aaf2c06db8e04dab417d61ced26c87">Cexplode_getAmnt</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the amount of pieces in exploded object Must not be called before calling Cexplode.  <a href="#a87aaf2c06db8e04dab417d61ced26c87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f">Cexplode</a> (const char *string, const char *delim, <a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explodes string to pieces according to delimiter. Result is stored in exp_obj and can be retrieved using functions below The results of explosion are stored in same order as they occurred in initial string, eg. if string "1 2 3 4" would be exploded with space (" ") as delimiter, <a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6" title="Get&#39;s the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.">Cexplode_getfirst()</a> would return 1, <a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a" title="Retrieve&#39;s Nth exploded piece - first is first (index starts from 1, not from...">Cexplode_getNth()</a> with n being 4, would return 4.  <a href="#a1c975295ecd9dc44ad145b912924d09f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a3bde5412faee7e4bd72fb176e9512753">Cexplode_nextexists</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peeks if there's another result in exp_obj. Must not be called before calling Cexplode.  <a href="#a3bde5412faee7e4bd72fb176e9512753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a">Cexplode_getNth</a> (int index, <a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve's Nth exploded piece - first is first (index starts from 1, not from 0) Updates internal iterator, IE following call to Cexplode_getnext will retrieve index+1th piece.  <a href="#a70206fa6bc4d5b81df9368a8bcf04d6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6">Cexplode_getfirst</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get's the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.  <a href="#ad5313efc1607b587d5f50f9e7da53ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ad5a89f298b77859208dd3dfa89ed52bb">Cexplode_getnext</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get's next piece. Returns NULL if no more pieces are around.  <a href="#ad5a89f298b77859208dd3dfa89ed52bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ad26d2c6306f4e0bf10087eb2eee11f00">Cexplode_getlast</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets last exploded piece.  <a href="#ad26d2c6306f4e0bf10087eb2eee11f00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#aa24158d63e276373bcbbfa90ab6fb146">Cexplode_free</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees resources allocated by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> - BEWARE frees also splitted pieces.  <a href="#aa24158d63e276373bcbbfa90ab6fb146"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ad8e605812dfbf6163681d9bab9319865">Cexplode_free_allButPieces</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees resources allocated by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> - does not free splitted pieces.  <a href="#ad8e605812dfbf6163681d9bab9319865"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a699fb49d95ecd0e6dd6f78154d31d4b9">Cexplode_getlentilllast</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the amount of chars from the start of the original string to the beginning of last found delimiter.  <a href="#a699fb49d95ecd0e6dd6f78154d31d4b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ac2408bb0b5a263ba5b658c3e76bd8aae">Cexplode_sepwasatend</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> exp_obj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns 1 if last chars in original string were the separator - else returns 0  <a href="#ac2408bb0b5a263ba5b658c3e76bd8aae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ac5f54fec027cf99f81ac4a3edcc455ba">Cexplode_concat</a> (<a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *first, <a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *second)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenates two exp_objs into one. Modifies the first argument to contain new exp_obj. Does not modify second argument.  <a href="#ac5f54fec027cf99f81ac4a3edcc455ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ab4c627dce0eaddfcd3d9d1b505a18713">mbot_ltrim</a> (char *text, char trimchar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes trimchars from the beginning of a string.  <a href="#ab4c627dce0eaddfcd3d9d1b505a18713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a9eed4d84ba25aac861d2f0e98ebea1c5">mbot_rtrim</a> (char *text, char trimchar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes trailing trimchars from a string.  <a href="#a9eed4d84ba25aac861d2f0e98ebea1c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ab752695ff718498402b26b700df6e47d">mbot_lrtrim</a> (char *text, char trimchar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes trailing trimchars as well as trimchars from the beginning of a string.  <a href="#ab752695ff718498402b26b700df6e47d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a03ca89b146a62235f864d1edf9a6c17a">mbot_trimall</a> (char *text, char trimchar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes all trimchars from a string.  <a href="#a03ca89b146a62235f864d1edf9a6c17a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a1b4ac4b4fdc05e131fe19317a7372f30">MbotAtomic32Init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates 32bit atomic variable, compatible with mbot_atomic* operations.  <a href="#a1b4ac4b4fdc05e131fe19317a7372f30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a95db6f58cb65aa522628a12b050e30a4">MbotAtomic32Uninit</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> **_this_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninitializes <a class="el" href="structMbotAtomic32.html" title="Struct for 32bit wide integer type used in atomic operations.">MbotAtomic32</a>. This must not be called when it is possible someone is using the variable.  <a href="#a95db6f58cb65aa522628a12b050e30a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a5a8246f0a9d2ecb397669fee0db5354a">mbot_atomicGet</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *atomic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value atomically.  <a href="#a5a8246f0a9d2ecb397669fee0db5354a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a7f3dbff0ae27bbe42ed27ca4667bc34c">mbot_atomicAdd</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *atomic, unsigned int addition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase value atomically - returns value before increment.  <a href="#a7f3dbff0ae27bbe42ed27ca4667bc34c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a82788623f2bcdb4ea8744bf6ed4627b2">mbot_atomicDec</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *atomic, unsigned int decrement)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease value atomically - returns value before decrement.  <a href="#a82788623f2bcdb4ea8744bf6ed4627b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ac03b6050ac2b1ee4f6238a632169f77c">mbot_atomicDecIfGreater</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *atomic, unsigned int decrement, unsigned int cmp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease value atomically, if original value is greater than cmp. Returns original value. (If returnval&lt;cmp, no decrement occurred.  <a href="#ac03b6050ac2b1ee4f6238a632169f77c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a4646872a8b03fd6ea4c2089199e1063d">mbot_atomicDecIfSmaller</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *atomic, unsigned int decrement, unsigned int cmp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease value atomically, if original value is smaller than cmp. Returns original value. (If returnval&gt;cmp, no decrement occurred.  <a href="#a4646872a8b03fd6ea4c2089199e1063d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a671ac1b259648d989ab1a029c28e2098">mbot_atomicIncIfGreater</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *atomic, unsigned int decrement, unsigned int cmp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase value atomically, if original value is greater than cmp. Returns original value. (If returnval&lt;cmp, no increment occurred.  <a href="#a671ac1b259648d989ab1a029c28e2098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#ac7d98784c664e65af53c0b148f6d489d">mbot_atomicIncIfSmaller</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *atomic, unsigned int decrement, unsigned int cmp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase value atomically, if original value is smaller than cmp. Returns original value. (If returnval&gt;cmp, no increment occurred.  <a href="#ac7d98784c664e65af53c0b148f6d489d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#aeda3837358237de6a1eb3b85a65e0a31">mbot_atomicCAS</a> (<a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *atomic, unsigned int old, unsigned int newval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#aaba224cf37291b1eda34e81b7cb20908">mbot_ll_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes linked list for use - returns ptr to list head.  <a href="#aaba224cf37291b1eda34e81b7cb20908"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#aff75d19cf19dd7b2f240d6b5db7ee9f1">mbot_ll_get_prev</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets previous list item. - returns previous item, or NULL if error occurred/first item given as param.  <a href="#aff75d19cf19dd7b2f240d6b5db7ee9f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a95294a003b1090373662c6078b7b7e1e">mbot_ll_head_get</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the head of the list Head can be used to maintain the location of empty list.  <a href="#a95294a003b1090373662c6078b7b7e1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a1879101758161a8c84cb1328e139c48c">mbot_ll_get_next</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get's next element - NULL if error occurred, or last element was provided as argument.  <a href="#a1879101758161a8c84cb1328e139c48c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a94dcac055f867e366648e84423a07a19">mbot_ll_get_first</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get's the first list element - returns first element or NULL if no elements stored, or if an error occurred.  <a href="#a94dcac055f867e366648e84423a07a19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a5f363fd2b3973f5fa633b69becc50fae">mbot_ll_get_last</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the last element in list.  <a href="#a5f363fd2b3973f5fa633b69becc50fae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a769e3f1537a2deafaf1c2d5a5f54168e">mbot_ll_add</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds item to list (data). Does not do a copy of data. Any list item (including head) can be used as _this.  <a href="#a769e3f1537a2deafaf1c2d5a5f54168e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#aeb38ace1d40a50bcd134a3acac02a59f">mbot_ll_release</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes given item from list - does not free memory.  <a href="#aeb38ace1d40a50bcd134a3acac02a59f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a138c3d10e29df5cd4c297968b4060a3f">mbot_ll_safe_release</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes list item which holds data pointed by data. Any list item can be given in _this. Does not free memory. Returns removed list entry, and user must call free upon entry and stored data.  <a href="#a138c3d10e29df5cd4c297968b4060a3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a00376130aa19ea61cfaba96d7d4846f1">mbot_ll_dataGet</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets data stored to an entry - entry and data are left untouched.  <a href="#a00376130aa19ea61cfaba96d7d4846f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a92753b0d798628f305538fc6cb336c6d">mbot_ll_dataSet</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets data to an list,.  <a href="#a92753b0d798628f305538fc6cb336c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a7c6856a86bfde414b76a317bf94f6a9f">mbot_ll_seek</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *_this, void *data, size_t datasize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searchs through the list and returns element in which the held data matches data specified in params.  <a href="#a7c6856a86bfde414b76a317bf94f6a9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a1837ee000be4ff885fabb90fbab82341">mbot_ll_copylist_wdata</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *old, size_t itemsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies given list and itemsize bytes of data from each container to new list, and returns a pointer to the copylist.  <a href="#a1837ee000be4ff885fabb90fbab82341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="helpers_8h.html#a6ae40d44caf944ad6b34f1a84dfa1f51">mbot_ll_destroy</a> (<a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> **_this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees all entries from list, and destroys the list - does not free stored data. _this is NULLed upon return.  <a href="#a6ae40d44caf944ad6b34f1a84dfa1f51"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="abfdc88c318ac17df371af7b475163783"></a><!-- doxytag: member="helpers.h::CEXPLODE_LAST_ITEM" ref="abfdc88c318ac17df371af7b475163783" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEXPLODE_LAST_ITEM&nbsp;&nbsp;&nbsp;0xFFFFFFFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a56c8f0f14ff2d468fabe0d3f568181df"></a><!-- doxytag: member="helpers.h::ECexplodeRet" ref="a56c8f0f14ff2d468fabe0d3f568181df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="helpers_8h.html#a56c8f0f14ff2d468fabe0d3f568181df">ECexplodeRet</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>enumeration for Cexplodei's error return values </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a56c8f0f14ff2d468fabe0d3f568181dfaaa011f9fda77271b2b6da4802a542aab"></a><!-- doxytag: member="ECexplodeRet_InternalFailure" ref="a56c8f0f14ff2d468fabe0d3f568181dfaaa011f9fda77271b2b6da4802a542aab" args="" -->ECexplodeRet_InternalFailure</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a56c8f0f14ff2d468fabe0d3f568181dfaa2ae017306e779c0558ea650bbc9fc78"></a><!-- doxytag: member="ECexplodeRet_InvalidParams" ref="a56c8f0f14ff2d468fabe0d3f568181dfaa2ae017306e779c0558ea650bbc9fc78" args="" -->ECexplodeRet_InvalidParams</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1c975295ecd9dc44ad145b912924d09f"></a><!-- doxytag: member="helpers.h::Cexplode" ref="a1c975295ecd9dc44ad145b912924d09f" args="(const char *string, const char *delim, CexplodeStrings *exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cexplode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explodes string to pieces according to delimiter. Result is stored in exp_obj and can be retrieved using functions below The results of explosion are stored in same order as they occurred in initial string, eg. if string "1 2 3 4" would be exploded with space (" ") as delimiter, <a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6" title="Get&#39;s the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.">Cexplode_getfirst()</a> would return 1, <a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a" title="Retrieve&#39;s Nth exploded piece - first is first (index starts from 1, not from...">Cexplode_getNth()</a> with n being 4, would return 4. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>char *string pointer to C string being exploded </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>char *delim pointer to C string used as delimiter for cutting original string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*exp_obj pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, which will be filled to contain results of explosion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>amount of pieces - number smaller than 1 if an error occurs </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a>, <a class="el" href="helpers_8h.html#a64d6e9e5a93f8eab6d85501b9b50f5b4" title="Removes the previously returned piece.">Cexplode_removeCurrent</a>, <a class="el" href="helpers_8h.html#a0c82e1b2630b7538bc756ffc7eaaeb9e" title="Removes Nth piece from cexplode Must not be called before calling Cexplode If removed...">Cexplode_removeNth</a>, <a class="el" href="helpers_8h.html#a87aaf2c06db8e04dab417d61ced26c87" title="Get the amount of pieces in exploded object Must not be called before calling Cexplode...">Cexplode_getAmnt</a>, <a class="el" href="helpers_8h.html#a3bde5412faee7e4bd72fb176e9512753" title="Peeks if there&#39;s another result in exp_obj. Must not be called before calling...">Cexplode_nextexists</a>, <a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a" title="Retrieve&#39;s Nth exploded piece - first is first (index starts from 1, not from...">Cexplode_getNth</a>, <a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6" title="Get&#39;s the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.">Cexplode_getfirst</a>, <a class="el" href="helpers_8h.html#ad5a89f298b77859208dd3dfa89ed52bb" title="Get&#39;s next piece. Returns NULL if no more pieces are around.">Cexplode_getnext</a>, <a class="el" href="helpers_8h.html#ad26d2c6306f4e0bf10087eb2eee11f00" title="Gets last exploded piece.">Cexplode_getlast</a>, <a class="el" href="helpers_8h.html#aa24158d63e276373bcbbfa90ab6fb146" title="Frees resources allocated by call to Cexplode() - BEWARE frees also splitted pieces...">Cexplode_free</a>, <a class="el" href="helpers_8h.html#ad8e605812dfbf6163681d9bab9319865" title="Frees resources allocated by call to Cexplode() - does not free splitted pieces.">Cexplode_free_allButPieces</a>, <a class="el" href="helpers_8h.html#a699fb49d95ecd0e6dd6f78154d31d4b9" title="Gets the amount of chars from the start of the original string to the beginning of...">Cexplode_getlentilllast</a>, <a class="el" href="helpers_8h.html#ac2408bb0b5a263ba5b658c3e76bd8aae" title="returns 1 if last chars in original string were the separator - else returns 0">Cexplode_sepwasatend</a>, <a class="el" href="helpers_8h.html#ac5f54fec027cf99f81ac4a3edcc455ba" title="Concatenates two exp_objs into one. Modifies the first argument to contain new exp_obj...">Cexplode_concat</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac5f54fec027cf99f81ac4a3edcc455ba"></a><!-- doxytag: member="helpers.h::Cexplode_concat" ref="ac5f54fec027cf99f81ac4a3edcc455ba" args="(CexplodeStrings *first, CexplodeStrings *second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cexplode_concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>second</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Concatenates two exp_objs into one. Modifies the first argument to contain new exp_obj. Does not modify second argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*first pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> to be combined with another <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> object. This will contain new <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> object holding results for both of the original <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> objects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*second ointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> to be combined with another <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> object - this will not be modified during call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of pieces in new exp_obj - negative number upon error. </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode for both first and second argument. </dd></dl>

</div>
</div>
<a class="anchor" id="aa24158d63e276373bcbbfa90ab6fb146"></a><!-- doxytag: member="helpers.h::Cexplode_free" ref="aa24158d63e276373bcbbfa90ab6fb146" args="(CexplodeStrings exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cexplode_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a>&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees resources allocated by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> - BEWARE frees also splitted pieces. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>exp_obj <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode </dd>
<dd>
BEWARE frees also splitted pieces, in which the returned pointers by Cexplode_get* points. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#ad8e605812dfbf6163681d9bab9319865" title="Frees resources allocated by call to Cexplode() - does not free splitted pieces.">Cexplode_free_allButPieces</a>, <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a" title="Retrieve&#39;s Nth exploded piece - first is first (index starts from 1, not from...">Cexplode_getNth</a>, <a class="el" href="helpers_8h.html#ad5a89f298b77859208dd3dfa89ed52bb" title="Get&#39;s next piece. Returns NULL if no more pieces are around.">Cexplode_getnext</a>, <a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6" title="Get&#39;s the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.">Cexplode_getfirst</a>, <a class="el" href="helpers_8h.html#ad26d2c6306f4e0bf10087eb2eee11f00" title="Gets last exploded piece.">Cexplode_getlast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e605812dfbf6163681d9bab9319865"></a><!-- doxytag: member="helpers.h::Cexplode_free_allButPieces" ref="ad8e605812dfbf6163681d9bab9319865" args="(CexplodeStrings exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cexplode_free_allButPieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a>&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees resources allocated by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> - does not free splitted pieces. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>exp_obj <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#aa24158d63e276373bcbbfa90ab6fb146" title="Frees resources allocated by call to Cexplode() - BEWARE frees also splitted pieces...">Cexplode_free</a>, <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a" title="Retrieve&#39;s Nth exploded piece - first is first (index starts from 1, not from...">Cexplode_getNth</a>, <a class="el" href="helpers_8h.html#ad5a89f298b77859208dd3dfa89ed52bb" title="Get&#39;s next piece. Returns NULL if no more pieces are around.">Cexplode_getnext</a>, <a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6" title="Get&#39;s the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.">Cexplode_getfirst</a>, <a class="el" href="helpers_8h.html#ad26d2c6306f4e0bf10087eb2eee11f00" title="Gets last exploded piece.">Cexplode_getlast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a87aaf2c06db8e04dab417d61ced26c87"></a><!-- doxytag: member="helpers.h::Cexplode_getAmnt" ref="a87aaf2c06db8e04dab417d61ced26c87" args="(CexplodeStrings exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cexplode_getAmnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a>&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the amount of pieces in exploded object Must not be called before calling Cexplode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*exp_obj pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>amount of exploded pieces stored in <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> container </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5313efc1607b587d5f50f9e7da53ac6"></a><!-- doxytag: member="helpers.h::Cexplode_getfirst" ref="ad5313efc1607b587d5f50f9e7da53ac6" args="(CexplodeStrings *exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Cexplode_getfirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get's the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*exp_obj pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL on error, othervice a pointer to result stored in Cexplode object </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a" title="Retrieve&#39;s Nth exploded piece - first is first (index starts from 1, not from...">Cexplode_getNth</a>, <a class="el" href="helpers_8h.html#ad5a89f298b77859208dd3dfa89ed52bb" title="Get&#39;s next piece. Returns NULL if no more pieces are around.">Cexplode_getnext</a>, <a class="el" href="helpers_8h.html#ad26d2c6306f4e0bf10087eb2eee11f00" title="Gets last exploded piece.">Cexplode_getlast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad26d2c6306f4e0bf10087eb2eee11f00"></a><!-- doxytag: member="helpers.h::Cexplode_getlast" ref="ad26d2c6306f4e0bf10087eb2eee11f00" args="(CexplodeStrings *exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Cexplode_getlast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets last exploded piece. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*exp_obj pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL on error, othervice a pointer to result stored in Cexplode object </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a" title="Retrieve&#39;s Nth exploded piece - first is first (index starts from 1, not from...">Cexplode_getNth</a>, <a class="el" href="helpers_8h.html#ad5a89f298b77859208dd3dfa89ed52bb" title="Get&#39;s next piece. Returns NULL if no more pieces are around.">Cexplode_getnext</a>, <a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6" title="Get&#39;s the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.">Cexplode_getfirst</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a699fb49d95ecd0e6dd6f78154d31d4b9"></a><!-- doxytag: member="helpers.h::Cexplode_getlentilllast" ref="a699fb49d95ecd0e6dd6f78154d31d4b9" args="(CexplodeStrings exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cexplode_getlentilllast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a>&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the amount of chars from the start of the original string to the beginning of last found delimiter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>exp_obj <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>amount of chars from the start of the original string to the beginning of last found delimiter </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#ac2408bb0b5a263ba5b658c3e76bd8aae" title="returns 1 if last chars in original string were the separator - else returns 0">Cexplode_sepwasatend</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5a89f298b77859208dd3dfa89ed52bb"></a><!-- doxytag: member="helpers.h::Cexplode_getnext" ref="ad5a89f298b77859208dd3dfa89ed52bb" args="(CexplodeStrings *exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Cexplode_getnext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get's next piece. Returns NULL if no more pieces are around. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*exp_obj pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL on error, othervice a pointer to result stored in Cexplode object </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#a70206fa6bc4d5b81df9368a8bcf04d6a" title="Retrieve&#39;s Nth exploded piece - first is first (index starts from 1, not from...">Cexplode_getNth</a>, <a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6" title="Get&#39;s the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.">Cexplode_getfirst</a>, <a class="el" href="helpers_8h.html#ad26d2c6306f4e0bf10087eb2eee11f00" title="Gets last exploded piece.">Cexplode_getlast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70206fa6bc4d5b81df9368a8bcf04d6a"></a><!-- doxytag: member="helpers.h::Cexplode_getNth" ref="a70206fa6bc4d5b81df9368a8bcf04d6a" args="(int index, CexplodeStrings *exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Cexplode_getNth </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve's Nth exploded piece - first is first (index starts from 1, not from 0) Updates internal iterator, IE following call to Cexplode_getnext will retrieve index+1th piece. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>index index number of result to be retrieved. first is first (index starts from 1, not from 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*exp_obj pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL on error, othervice a pointer to result stored in Cexplode object </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#ad5313efc1607b587d5f50f9e7da53ac6" title="Get&#39;s the first exploded piece. Same as Cexplode_getNth(1,*exp_obj);.">Cexplode_getfirst</a>, <a class="el" href="helpers_8h.html#ad5a89f298b77859208dd3dfa89ed52bb" title="Get&#39;s next piece. Returns NULL if no more pieces are around.">Cexplode_getnext</a>, <a class="el" href="helpers_8h.html#ad26d2c6306f4e0bf10087eb2eee11f00" title="Gets last exploded piece.">Cexplode_getlast</a>, <a class="el" href="helpers_8h.html#a87aaf2c06db8e04dab417d61ced26c87" title="Get the amount of pieces in exploded object Must not be called before calling Cexplode...">Cexplode_getAmnt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bde5412faee7e4bd72fb176e9512753"></a><!-- doxytag: member="helpers.h::Cexplode_nextexists" ref="a3bde5412faee7e4bd72fb176e9512753" args="(CexplodeStrings exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cexplode_nextexists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a>&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peeks if there's another result in exp_obj. Must not be called before calling Cexplode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>exp_obj <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if next piece exists (Eg. if Cexplode_getnext et al. can be safely used), 0 if there's no next result in object. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#ad5a89f298b77859208dd3dfa89ed52bb" title="Get&#39;s next piece. Returns NULL if no more pieces are around.">Cexplode_getnext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a64d6e9e5a93f8eab6d85501b9b50f5b4"></a><!-- doxytag: member="helpers.h::Cexplode_removeCurrent" ref="a64d6e9e5a93f8eab6d85501b9b50f5b4" args="(CexplodeStrings *exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cexplode_removeCurrent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the previously returned piece. </p>
<p>Must not be called before calling Cexplode If removed item is last piece, the "sepwasatend" flag will be set true</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*exp_obj pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 at success, -1 at failure </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#a0c82e1b2630b7538bc756ffc7eaaeb9e" title="Removes Nth piece from cexplode Must not be called before calling Cexplode If removed...">Cexplode_removeNth</a>, <a class="el" href="helpers_8h.html#a87aaf2c06db8e04dab417d61ced26c87" title="Get the amount of pieces in exploded object Must not be called before calling Cexplode...">Cexplode_getAmnt</a>, <a class="el" href="helpers_8h.html#a3bde5412faee7e4bd72fb176e9512753" title="Peeks if there&#39;s another result in exp_obj. Must not be called before calling...">Cexplode_nextexists</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c82e1b2630b7538bc756ffc7eaaeb9e"></a><!-- doxytag: member="helpers.h::Cexplode_removeNth" ref="a0c82e1b2630b7538bc756ffc7eaaeb9e" args="(int nro, CexplodeStrings *exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Cexplode_removeNth </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a> *&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes Nth piece from cexplode Must not be called before calling Cexplode If removed item is last piece, the "sepwasatend" flag will be set true! Note, you can use special CEXPLODE_LAST_ITEM define to remove the last item. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>nro number of exploded piece to be removed from the <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> containing results </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>*exp_obj pointer to <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ptr to removed string </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#a64d6e9e5a93f8eab6d85501b9b50f5b4" title="Removes the previously returned piece.">Cexplode_removeCurrent</a>, <a class="el" href="helpers_8h.html#a87aaf2c06db8e04dab417d61ced26c87" title="Get the amount of pieces in exploded object Must not be called before calling Cexplode...">Cexplode_getAmnt</a>, <a class="el" href="helpers_8h.html#a3bde5412faee7e4bd72fb176e9512753" title="Peeks if there&#39;s another result in exp_obj. Must not be called before calling...">Cexplode_nextexists</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac2408bb0b5a263ba5b658c3e76bd8aae"></a><!-- doxytag: member="helpers.h::Cexplode_sepwasatend" ref="ac2408bb0b5a263ba5b658c3e76bd8aae" args="(CexplodeStrings exp_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cexplode_sepwasatend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCexplodeStrings.html">CexplodeStrings</a>&nbsp;</td>
          <td class="paramname"> <em>exp_obj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns 1 if last chars in original string were the separator - else returns 0 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a></em>&nbsp;</td><td>exp_obj <a class="el" href="structCexplodeStrings.html" title="Struct for Cexplode object.">CexplodeStrings</a> type object, filled by call to <a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if last chars in original string were the separator - else returns 0 </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Must not be called before calling Cexplode </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="helpers_8h.html#a1c975295ecd9dc44ad145b912924d09f" title="Explodes string to pieces according to delimiter. Result is stored in exp_obj and...">Cexplode</a>, <a class="el" href="helpers_8h.html#a699fb49d95ecd0e6dd6f78154d31d4b9" title="Gets the amount of chars from the start of the original string to the beginning of...">Cexplode_getlentilllast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f3dbff0ae27bbe42ed27ca4667bc34c"></a><!-- doxytag: member="helpers.h::mbot_atomicAdd" ref="a7f3dbff0ae27bbe42ed27ca4667bc34c" args="(MbotAtomic32 *atomic, unsigned int addition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mbot_atomicAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td>
          <td class="paramname"> <em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>addition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase value atomically - returns value before increment. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If non x86 arch is used, these atomic ops are ineffective dummies using a huge semaphore (provided only for compatibility). On x86 arch compile with define ARCH_x86 </dd></dl>

</div>
</div>
<a class="anchor" id="aeda3837358237de6a1eb3b85a65e0a31"></a><!-- doxytag: member="helpers.h::mbot_atomicCAS" ref="aeda3837358237de6a1eb3b85a65e0a31" args="(MbotAtomic32 *atomic, unsigned int old, unsigned int newval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mbot_atomicCAS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td>
          <td class="paramname"> <em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>newval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a82788623f2bcdb4ea8744bf6ed4627b2"></a><!-- doxytag: member="helpers.h::mbot_atomicDec" ref="a82788623f2bcdb4ea8744bf6ed4627b2" args="(MbotAtomic32 *atomic, unsigned int decrement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mbot_atomicDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td>
          <td class="paramname"> <em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>decrement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease value atomically - returns value before decrement. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If non x86 arch is used, these atomic ops are ineffective dummies using a huge semaphore (provided only for compatibility). On x86 arch compile with define ARCH_x86 </dd></dl>

</div>
</div>
<a class="anchor" id="ac03b6050ac2b1ee4f6238a632169f77c"></a><!-- doxytag: member="helpers.h::mbot_atomicDecIfGreater" ref="ac03b6050ac2b1ee4f6238a632169f77c" args="(MbotAtomic32 *atomic, unsigned int decrement, unsigned int cmp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mbot_atomicDecIfGreater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td>
          <td class="paramname"> <em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>decrement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cmp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease value atomically, if original value is greater than cmp. Returns original value. (If returnval&lt;cmp, no decrement occurred. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If non x86 arch is used, these atomic ops are ineffective dummies using a huge semaphore (provided only for compatibility). On x86 arch compile with define ARCH_x86 </dd></dl>

</div>
</div>
<a class="anchor" id="a4646872a8b03fd6ea4c2089199e1063d"></a><!-- doxytag: member="helpers.h::mbot_atomicDecIfSmaller" ref="a4646872a8b03fd6ea4c2089199e1063d" args="(MbotAtomic32 *atomic, unsigned int decrement, unsigned int cmp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mbot_atomicDecIfSmaller </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td>
          <td class="paramname"> <em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>decrement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cmp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease value atomically, if original value is smaller than cmp. Returns original value. (If returnval&gt;cmp, no decrement occurred. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If non x86 arch is used, these atomic ops are ineffective dummies using a huge semaphore (provided only for compatibility). On x86 arch compile with define ARCH_x86 </dd></dl>

</div>
</div>
<a class="anchor" id="a5a8246f0a9d2ecb397669fee0db5354a"></a><!-- doxytag: member="helpers.h::mbot_atomicGet" ref="a5a8246f0a9d2ecb397669fee0db5354a" args="(MbotAtomic32 *atomic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mbot_atomicGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td>
          <td class="paramname"> <em>atomic</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value atomically. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If non x86 arch is used, these atomic ops are ineffective dummies using a huge semaphore (provided only for compatibility). On x86 arch compile with define ARCH_x86 </dd></dl>

</div>
</div>
<a class="anchor" id="a671ac1b259648d989ab1a029c28e2098"></a><!-- doxytag: member="helpers.h::mbot_atomicIncIfGreater" ref="a671ac1b259648d989ab1a029c28e2098" args="(MbotAtomic32 *atomic, unsigned int decrement, unsigned int cmp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mbot_atomicIncIfGreater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td>
          <td class="paramname"> <em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>decrement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cmp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase value atomically, if original value is greater than cmp. Returns original value. (If returnval&lt;cmp, no increment occurred. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If non x86 arch is used, these atomic ops are ineffective dummies using a huge semaphore (provided only for compatibility). On x86 arch compile with define ARCH_x86 </dd></dl>

</div>
</div>
<a class="anchor" id="ac7d98784c664e65af53c0b148f6d489d"></a><!-- doxytag: member="helpers.h::mbot_atomicIncIfSmaller" ref="ac7d98784c664e65af53c0b148f6d489d" args="(MbotAtomic32 *atomic, unsigned int decrement, unsigned int cmp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mbot_atomicIncIfSmaller </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> *&nbsp;</td>
          <td class="paramname"> <em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>decrement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cmp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increase value atomically, if original value is smaller than cmp. Returns original value. (If returnval&gt;cmp, no increment occurred. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If non x86 arch is used, these atomic ops are ineffective dummies using a huge semaphore (provided only for compatibility). On x86 arch compile with define ARCH_x86 </dd></dl>

</div>
</div>
<a class="anchor" id="a769e3f1537a2deafaf1c2d5a5f54168e"></a><!-- doxytag: member="helpers.h::mbot_ll_add" ref="a769e3f1537a2deafaf1c2d5a5f54168e" args="(mbot_linkedList *_this, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds item to list (data). Does not do a copy of data. Any list item (including head) can be used as _this. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>list entry corresponding to stored data </dd></dl>

</div>
</div>
<a class="anchor" id="a1837ee000be4ff885fabb90fbab82341"></a><!-- doxytag: member="helpers.h::mbot_ll_copylist_wdata" ref="a1837ee000be4ff885fabb90fbab82341" args="(mbot_linkedList *old, size_t itemsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_copylist_wdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>itemsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies given list and itemsize bytes of data from each container to new list, and returns a pointer to the copylist. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the copylist and NULL on error </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This assumes that each "container" in list holds at least itemsize bytes of data - and copies exactly itemsize bytes. </dd>
<dd>
Usable really only for lists which hold fixed size items! </dd></dl>

</div>
</div>
<a class="anchor" id="a00376130aa19ea61cfaba96d7d4846f1"></a><!-- doxytag: member="helpers.h::mbot_ll_dataGet" ref="a00376130aa19ea61cfaba96d7d4846f1" args="(mbot_linkedList *_this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mbot_ll_dataGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets data stored to an entry - entry and data are left untouched. </p>

</div>
</div>
<a class="anchor" id="a92753b0d798628f305538fc6cb336c6d"></a><!-- doxytag: member="helpers.h::mbot_ll_dataSet" ref="a92753b0d798628f305538fc6cb336c6d" args="(mbot_linkedList *_this, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mbot_ll_dataSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets data to an list,. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>previous data </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>- this should be avoided. Malicious use may corrupt the list! </dd></dl>

</div>
</div>
<a class="anchor" id="a6ae40d44caf944ad6b34f1a84dfa1f51"></a><!-- doxytag: member="helpers.h::mbot_ll_destroy" ref="a6ae40d44caf944ad6b34f1a84dfa1f51" args="(mbot_linkedList **_this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbot_ll_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> **&nbsp;</td>
          <td class="paramname"> <em>_this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees all entries from list, and destroys the list - does not free stored data. _this is NULLed upon return. </p>

</div>
</div>
<a class="anchor" id="a94dcac055f867e366648e84423a07a19"></a><!-- doxytag: member="helpers.h::mbot_ll_get_first" ref="a94dcac055f867e366648e84423a07a19" args="(mbot_linkedList *_this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_get_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get's the first list element - returns first element or NULL if no elements stored, or if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a5f363fd2b3973f5fa633b69becc50fae"></a><!-- doxytag: member="helpers.h::mbot_ll_get_last" ref="a5f363fd2b3973f5fa633b69becc50fae" args="(mbot_linkedList *_this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_get_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the last element in list. </p>

</div>
</div>
<a class="anchor" id="a1879101758161a8c84cb1328e139c48c"></a><!-- doxytag: member="helpers.h::mbot_ll_get_next" ref="a1879101758161a8c84cb1328e139c48c" args="(mbot_linkedList *_this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_get_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get's next element - NULL if error occurred, or last element was provided as argument. </p>

</div>
</div>
<a class="anchor" id="aff75d19cf19dd7b2f240d6b5db7ee9f1"></a><!-- doxytag: member="helpers.h::mbot_ll_get_prev" ref="aff75d19cf19dd7b2f240d6b5db7ee9f1" args="(mbot_linkedList *_this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_get_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets previous list item. - returns previous item, or NULL if error occurred/first item given as param. </p>

</div>
</div>
<a class="anchor" id="a95294a003b1090373662c6078b7b7e1e"></a><!-- doxytag: member="helpers.h::mbot_ll_head_get" ref="a95294a003b1090373662c6078b7b7e1e" args="(mbot_linkedList *_this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_head_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the head of the list Head can be used to maintain the location of empty list. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the head, and NULL on error </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>HEAD IS NOT SUPPOSED TO BE USED AS STORING ELEMENT! </dd></dl>

</div>
</div>
<a class="anchor" id="aaba224cf37291b1eda34e81b7cb20908"></a><!-- doxytag: member="helpers.h::mbot_ll_init" ref="aaba224cf37291b1eda34e81b7cb20908" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes linked list for use - returns ptr to list head. </p>

</div>
</div>
<a class="anchor" id="aeb38ace1d40a50bcd134a3acac02a59f"></a><!-- doxytag: member="helpers.h::mbot_ll_release" ref="aeb38ace1d40a50bcd134a3acac02a59f" args="(mbot_linkedList *_this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes given item from list - does not free memory. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>removed list entry, and user must call free upon entry and stored data. </dd></dl>

</div>
</div>
<a class="anchor" id="a138c3d10e29df5cd4c297968b4060a3f"></a><!-- doxytag: member="helpers.h::mbot_ll_safe_release" ref="a138c3d10e29df5cd4c297968b4060a3f" args="(mbot_linkedList *_this, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_safe_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes list item which holds data pointed by data. Any list item can be given in _this. Does not free memory. Returns removed list entry, and user must call free upon entry and stored data. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>removed list entry </dd></dl>

</div>
</div>
<a class="anchor" id="a7c6856a86bfde414b76a317bf94f6a9f"></a><!-- doxytag: member="helpers.h::mbot_ll_seek" ref="a7c6856a86bfde414b76a317bf94f6a9f" args="(mbot_linkedList *_this, void *data, size_t datasize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a>* mbot_ll_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbot__linkedList.html">mbot_linkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>_this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>datasize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searchs through the list and returns element in which the held data matches data specified in params. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>, all elements must contain at least as much data as specified in size_t datasize! </dd></dl>

</div>
</div>
<a class="anchor" id="ab752695ff718498402b26b700df6e47d"></a><!-- doxytag: member="helpers.h::mbot_lrtrim" ref="ab752695ff718498402b26b700df6e47d" args="(char *text, char trimchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbot_lrtrim </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>trimchar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes trailing trimchars as well as trimchars from the beginning of a string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of characters removed </dd></dl>

</div>
</div>
<a class="anchor" id="ab4c627dce0eaddfcd3d9d1b505a18713"></a><!-- doxytag: member="helpers.h::mbot_ltrim" ref="ab4c627dce0eaddfcd3d9d1b505a18713" args="(char *text, char trimchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbot_ltrim </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>trimchar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes trimchars from the beginning of a string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of characters removed </dd></dl>

</div>
</div>
<a class="anchor" id="a9eed4d84ba25aac861d2f0e98ebea1c5"></a><!-- doxytag: member="helpers.h::mbot_rtrim" ref="a9eed4d84ba25aac861d2f0e98ebea1c5" args="(char *text, char trimchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbot_rtrim </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>trimchar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes trailing trimchars from a string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of characters removed </dd></dl>

</div>
</div>
<a class="anchor" id="a03ca89b146a62235f864d1edf9a6c17a"></a><!-- doxytag: member="helpers.h::mbot_trimall" ref="a03ca89b146a62235f864d1edf9a6c17a" args="(char *text, char trimchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbot_trimall </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>trimchar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes all trimchars from a string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of characters removed </dd></dl>

</div>
</div>
<a class="anchor" id="a1b4ac4b4fdc05e131fe19317a7372f30"></a><!-- doxytag: member="helpers.h::MbotAtomic32Init" ref="a1b4ac4b4fdc05e131fe19317a7372f30" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a>* MbotAtomic32Init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates 32bit atomic variable, compatible with mbot_atomic* operations. </p>

</div>
</div>
<a class="anchor" id="a95db6f58cb65aa522628a12b050e30a4"></a><!-- doxytag: member="helpers.h::MbotAtomic32Uninit" ref="a95db6f58cb65aa522628a12b050e30a4" args="(MbotAtomic32 **_this_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MbotAtomic32Uninit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMbotAtomic32.html">MbotAtomic32</a> **&nbsp;</td>
          <td class="paramname"> <em>_this_</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uninitializes <a class="el" href="structMbotAtomic32.html" title="Struct for 32bit wide integer type used in atomic operations.">MbotAtomic32</a>. This must not be called when it is possible someone is using the variable. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If non x86 arch is used, these atomic ops are ineffective dummies using a huge semaphore (provided only for compatibility). On x86 arch compile with define ARCH_x86 </dd></dl>

</div>
</div>
</div>
<br />
<br />
<p>
<a href="http://teotilcan.net/svn/MazBot/generic/src/">Most recent version</a><br /><a href="http://teotilcan.net/tracker/view_all_bug_page.php">Bug tracker</a><br /><a href="http://maz-programmersdiary.blogspot.com/">Maz - programmer's diary</a><br /><i>Contact: Mazziesaccount@gmail.com</i>
</body>
</html>
